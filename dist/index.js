/*! For license information please see index.js.LICENSE.txt */
(()=>{"use strict";var __webpack_modules__={"./src/api/clickerheroes.ts":function(__unused_webpack_module,exports,__webpack_require__){eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"axios\"));\nconst code_1 = __importDefault(__webpack_require__(/*! ../shared/code */ \"./src/shared/code.ts\"));\nvar ClickerHeroesAPI;\n(function (ClickerHeroesAPI) {\n    async function request(request, params) {\n        const ENDPOINT = 'http://ClickerHeroes-SavedGames3-747864888.us-east-1.elb.amazonaws.com';\n        try {\n            const response = await (0, axios_1.default)({\n                method: 'post',\n                url: `${ENDPOINT}/clans/${request}.php`,\n                params: params,\n                headers: {\n                    'Content-type': 'application/x-www-form-urlencoded'\n                }\n            });\n            const data = response.data;\n            if (!data.success) {\n                throw {\n                    code: code_1.default.CLICKERHEROES_API_FAILED,\n                    message: data.reason\n                };\n            }\n            return data.result;\n        }\n        catch (error) {\n            if (error.code === code_1.default.CLICKERHEROES_API_FAILED) {\n                throw error;\n            }\n            else if (error.request) {\n                throw ({\n                    code: code_1.default.NO_RESPONSE\n                });\n            }\n            else {\n                throw ({\n                    code: code_1.default.INTERNAL_SERVER_ERROR,\n                    message: error.message\n                });\n            }\n        }\n    }\n    async function getGuildInfo(uid, pwd) {\n        return await request('getGuildInfo', { uid: uid, passwordHash: pwd });\n    }\n    ClickerHeroesAPI.getGuildInfo = getGuildInfo;\n    async function getNewRaid(uid, pwd, guildName) {\n        return await request('getNewRaid', { uid: uid, passwordHash: pwd, guildName: guildName });\n    }\n    ClickerHeroesAPI.getNewRaid = getNewRaid;\n    async function getGuildMessages(uid, pwd, guildName) {\n        return await request('getGuildMessages', { uid: uid, passwordHash: pwd, guildName: guildName, timestamp: (Date.now() / 1000) });\n    }\n    ClickerHeroesAPI.getGuildMessages = getGuildMessages;\n})(ClickerHeroesAPI || (ClickerHeroesAPI = {}));\nexports[\"default\"] = ClickerHeroesAPI;\n\n\n//# sourceURL=webpack://borbot/./src/api/clickerheroes.ts?")},"./src/api/discord.ts":function(__unused_webpack_module,exports,__webpack_require__){eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"axios\"));\nconst code_1 = __importDefault(__webpack_require__(/*! ../shared/code */ \"./src/shared/code.ts\"));\nvar DiscordAPI;\n(function (DiscordAPI) {\n    async function request(method, path, data) {\n        try {\n            const response = await (0, axios_1.default)({\n                method: method,\n                url: `https://discord.com/api/v10/${path}`,\n                params: method === 'get' ? data.params : undefined,\n                data: method === 'post' ? data.params : undefined,\n                headers: data.headers\n            });\n            return response.data;\n        }\n        catch (error) {\n            if (error.response) {\n                throw ({\n                    code: code_1.default.DISCORD_API_ERROR,\n                    path: path,\n                    data: error.response.data,\n                    status: error.response.status\n                });\n            }\n            else if (error.request) {\n                throw ({\n                    code: code_1.default.NO_RESPONSE\n                });\n            }\n            else {\n                throw ({\n                    code: code_1.default.INTERNAL_SERVER_ERROR,\n                    message: error.message\n                });\n            }\n        }\n    }\n    DiscordAPI.request = request;\n    async function getAuthToken(clientID, clientSecret, clientCode) {\n        const params = {\n            client_id: clientID,\n            client_secret: clientSecret,\n            grant_type: 'authorization_code',\n            code: clientCode,\n            redirect_uri: `${process.env.SERVER_ADDRESS}:3010/api/auth`\n        };\n        return await request('post', 'oauth2/token', {\n            params: new URLSearchParams(params)\n        });\n    }\n    DiscordAPI.getAuthToken = getAuthToken;\n    async function getUserInformation(token) {\n        return await request('get', 'users/@me', {\n            headers: {\n                'Authorization': `Bearer ${token}`\n            }\n        });\n    }\n    DiscordAPI.getUserInformation = getUserInformation;\n    async function getUserGuilds(token, limit = 100) {\n        return await request('get', 'users/@me/guilds', {\n            params: { limit: limit },\n            headers: {\n                'Authorization': `Bearer ${token}`\n            }\n        });\n    }\n    DiscordAPI.getUserGuilds = getUserGuilds;\n})(DiscordAPI || (DiscordAPI = {}));\nexports[\"default\"] = DiscordAPI;\n\n\n//# sourceURL=webpack://borbot/./src/api/discord.ts?")},"./src/bot/actions.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Actions = void 0;\nconst announceRaids_1 = __webpack_require__(/*! ./actions/announceRaids */ "./src/bot/actions/announceRaids.ts");\nconst remindClaim_1 = __webpack_require__(/*! ./actions/remindClaim */ "./src/bot/actions/remindClaim.ts");\nconst updateChat_1 = __webpack_require__(/*! ./actions/updateChat */ "./src/bot/actions/updateChat.ts");\nconst updateSchedule_1 = __webpack_require__(/*! ./actions/updateSchedule */ "./src/bot/actions/updateSchedule.ts");\nconst updateUsers_1 = __webpack_require__(/*! ./actions/updateUsers */ "./src/bot/actions/updateUsers.ts");\nexports.Actions = [\n    updateUsers_1.UpdateUsers,\n    announceRaids_1.AnnounceRaids,\n    updateChat_1.UpdateChat,\n    remindClaim_1.RemindClaim,\n    updateSchedule_1.UpdateSchedule\n];\n\n\n//# sourceURL=webpack://borbot/./src/bot/actions.ts?')},"./src/bot/actions/announceRaids.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.AnnounceRaids = void 0;\nconst logger_1 = __importStar(__webpack_require__(/*! ../../shared/logger */ "./src/shared/logger.ts"));\nconst clanService_1 = __importDefault(__webpack_require__(/*! ../../services/clanService */ "./src/services/clanService.ts"));\nconst guildService_1 = __importDefault(__webpack_require__(/*! ../../services/guildService */ "./src/services/guildService.ts"));\nconst utils_1 = __webpack_require__(/*! ../../shared/utils */ "./src/shared/utils.ts");\nconst builders_1 = __webpack_require__(/*! @discordjs/builders */ "@discordjs/builders");\nconst discord_js_1 = __webpack_require__(/*! discord.js */ "discord.js");\nfunction composeMessage(mention, date, msg) {\n    return `${mention} **${(0, utils_1.dateToString)(date)}**\\n**${msg}**`;\n}\nexports.AnnounceRaids = {\n    run: async function (client, guild) {\n        const fetched = client.guilds.cache.get(guild.guild_id);\n        if (!fetched) {\n            (0, logger_1.default)(`#announceRaids Couldn\'t find guild with id ${guild.guild_id}`);\n            return;\n        }\n        const clan = await clanService_1.default.getClanInformation(guild.user_uid, guild.password_hash);\n        if (!clan) {\n            (0, logger_1.default)(`#announceRaids Invalid clan information`, logger_1.LoggerType.ERROR);\n            return;\n        }\n        const raid = await clanService_1.default.getClanNewRaid(guild.user_uid, guild.password_hash, clan.name);\n        const channel = fetched.channels.cache.get(guild.raid_announcement_channel || "");\n        if (!channel || channel.type !== discord_js_1.ChannelType.GuildText) {\n            (0, logger_1.default)("#announceRaids Invalid channel for raid announcements!", logger_1.LoggerType.WARN);\n            return;\n        }\n        const schedule = await guildService_1.default.getGuildSchedule(guild.guild_id);\n        if (!schedule) {\n            (0, logger_1.default)("#announceRaids Schedule wasn\'t setup!", logger_1.LoggerType.WARN);\n            return;\n        }\n        const currentDate = (0, utils_1.getDateMidnight)();\n        const checkedToday = schedule.last_checked && schedule.last_checked.getTime() === currentDate.getTime();\n        if (!checkedToday) {\n            const diff = (0, utils_1.dateDifference)(currentDate, schedule.cycle_start);\n            if (diff >= 10 || diff < 0) {\n                const cycles = Math.floor(diff / 10);\n                const newCycleTimestamp = schedule.cycle_start.getTime() + (cycles * 86400000 * 10);\n                schedule.cycle_start = new Date(newCycleTimestamp);\n            }\n            schedule.last_checked = currentDate;\n            schedule.loggedRaidSuccess = false;\n            schedule.loggedBonusRaidAvailable = false;\n            schedule.loggedBonusRaidSuccess = false;\n            await channel.send(composeMessage(guild.raid_fight_role ? (0, builders_1.roleMention)(guild.raid_fight_role) : "@everyone", currentDate, `First raid available! :crossed_swords:`));\n        }\n        if (!schedule.loggedRaidSuccess && raid.isSuccessful) {\n            schedule.loggedRaidSuccess = true;\n            let uid = "";\n            const cycleDay = (0, utils_1.dateDifference)(currentDate, schedule.cycle_start);\n            const scheduleMember = schedule.map.find(o => o.index === (cycleDay + 1));\n            if (scheduleMember && scheduleMember.member) {\n                uid = scheduleMember.member.guild_uid;\n            }\n            await channel.send(composeMessage(uid ? (0, builders_1.userMention)(uid) : "@everyone", currentDate, \'You can buy the bonus fight now! :coin:\'));\n        }\n        if (!schedule.loggedBonusRaidAvailable && raid.isBonusAvailable) {\n            schedule.loggedBonusRaidAvailable = true;\n            await channel.send(composeMessage(guild.raid_fight_role ? (0, builders_1.roleMention)(guild.raid_fight_role) : "@everyone", currentDate, `Second raid available! :crossed_swords:`));\n        }\n        if (!schedule.loggedBonusRaidSuccess && raid.isBonusSuccessful) {\n            schedule.loggedBonusRaidSuccess = true;\n            await channel.send(composeMessage(guild.raid_claim_role ? (0, builders_1.roleMention)(guild.raid_claim_role) : "@everyone", currentDate, `All fights completed! Collect your rewards! :gem:`));\n        }\n        await schedule.save();\n        (0, logger_1.default)(`#announceRaids in ${fetched.name}`);\n    },\n    startOnInit: true,\n    timeout: 5,\n    repeat: true\n};\n\n\n//# sourceURL=webpack://borbot/./src/bot/actions/announceRaids.ts?')},"./src/bot/actions/remindClaim.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.RemindClaim = void 0;\nconst logger_1 = __importStar(__webpack_require__(/*! ../../shared/logger */ "./src/shared/logger.ts"));\nconst clanService_1 = __importStar(__webpack_require__(/*! ../../services/clanService */ "./src/services/clanService.ts"));\nconst guildService_1 = __importDefault(__webpack_require__(/*! ../../services/guildService */ "./src/services/guildService.ts"));\nconst utils_1 = __webpack_require__(/*! ../../shared/utils */ "./src/shared/utils.ts");\nconst discord_js_1 = __webpack_require__(/*! discord.js */ "discord.js");\nasync function composeRemainder(guild_id, members, title) {\n    let msg = `**${title}**\\n`;\n    for (const member of members) {\n        msg += \'- \';\n        const dbMember = await guildService_1.default.getGuildConnectedMember({ guild_id: guild_id, clan_uid: member.uid });\n        if (!dbMember)\n            console.log(\'didnt dint\');\n        msg += (dbMember ? `<@${dbMember.guild_uid}>` : member.nickname);\n        msg += ` **The ${clanService_1.ClanClass[member.class]}**\\n`;\n    }\n    return msg;\n}\nexports.RemindClaim = {\n    run: async function (client, guild) {\n        const fetchedGuild = await client.guilds.cache.get(guild.guild_id);\n        if (!fetchedGuild) {\n            (0, logger_1.default)(`#remindClaim Couldn\'t get guild ${guild.guild_id}`);\n            return;\n        }\n        const lastReminded = (guild.last_reminded === undefined ? new Date("2000-01-01") : guild.last_reminded);\n        const currentDate = new Date(Date.now());\n        if (Math.floor((0, utils_1.dateDifference)(currentDate, lastReminded)) === 0 || currentDate.getUTCHours() !== 23)\n            return;\n        const clan = await clanService_1.default.getClanInformation(guild.user_uid, guild.password_hash);\n        if (!clan) {\n            (0, logger_1.default)(`#remindClaim Invalid clan information`, logger_1.LoggerType.ERROR);\n            return;\n        }\n        const raid = await clanService_1.default.getClanNewRaid(guild.user_uid, guild.password_hash, clan.name);\n        const channel = await fetchedGuild.channels.cache.get(guild.remind_channel || "");\n        if (!channel || channel.type !== discord_js_1.ChannelType.GuildText) {\n            (0, logger_1.default)(`#remindClaim Couldn\'t get valid channel`, logger_1.LoggerType.WARN);\n            return;\n        }\n        const missing = clan.members.filter(value => raid.scores.findIndex(o => o.uid === value.uid) === -1);\n        const missingBonus = clan.members.filter(value => raid.bonusScores.findIndex(o => o.uid === value.uid) === -1);\n        guild.last_reminded = (0, utils_1.getDateMidnight)(currentDate);\n        if (missing.length === 0 && missingBonus.length === 0)\n            return;\n        let msg = `:coin: **RAID REMINDER ${(0, utils_1.dateToString)(currentDate)}** :coin:\\n\\n`;\n        if (!raid.isSuccessful) {\n            msg += ":crossed_swords: FIRST RAID NOT COMPLETED :crossed_swords:\\n\\n";\n        }\n        else if (missing.length > 0) {\n            msg += await composeRemainder(guild.guild_id, missing, ":crossed_swords: FIRST RAID :crossed_swords:");\n            msg += \'\\n\';\n        }\n        if (!raid.isBonusSuccessful) {\n            msg += "**:gem: BONUS RAID NOT COMPLETED :gem:**\\n\\n";\n        }\n        else if (missingBonus.length > 0) {\n            msg += await composeRemainder(guild.guild_id, missingBonus, ":gem: BONUS RAID :gem:");\n            msg += \'\\n\';\n        }\n        msg += "**WARNING!** *Everyone mentioned, you have less then 1 hour to claim the rewards!*";\n        await channel.send(msg);\n        (0, logger_1.default)(`#remindClaim in ${fetchedGuild.name}`);\n    },\n    startOnInit: true,\n    repeat: true,\n    timeout: 5\n};\n\n\n//# sourceURL=webpack://borbot/./src/bot/actions/remindClaim.ts?')},"./src/bot/actions/updateChat.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.UpdateChat = void 0;\nconst discord_js_1 = __webpack_require__(/*! discord.js */ "discord.js");\nconst logger_1 = __importStar(__webpack_require__(/*! ../../shared/logger */ "./src/shared/logger.ts"));\nconst clanService_1 = __importDefault(__webpack_require__(/*! ../../services/clanService */ "./src/services/clanService.ts"));\nconst guildService_1 = __importDefault(__webpack_require__(/*! ../../services/guildService */ "./src/services/guildService.ts"));\nconst utils_1 = __webpack_require__(/*! ../../shared/utils */ "./src/shared/utils.ts");\nasync function processMentions(msg, guild, members) {\n    const splits = msg.split(/(@\\w*)/g);\n    if (splits.length === 0)\n        return msg;\n    let ret = "";\n    for (const split of splits) {\n        if (!split.startsWith(\'@\')) {\n            ret += split;\n            continue;\n        }\n        const name = split.slice(1);\n        const clanMember = members.find(o => o.nickname === name);\n        if (!clanMember) {\n            ret += split;\n            continue;\n        }\n        const dbMember = await guildService_1.default.getGuildConnectedMember({ guild_id: guild.id, clan_uid: clanMember.uid });\n        if (!dbMember) {\n            ret += split;\n            continue;\n        }\n        const guildMember = await guild.members.fetch(dbMember.guild_uid);\n        if (!guildMember) {\n            ret += split;\n            continue;\n        }\n        ret += `${guildMember}`;\n    }\n    return ret;\n}\nasync function processEmoji(msg, guild) {\n    const splits = msg.split(/(:\\b[^:]*\\b:)/g);\n    if (splits.length === 0)\n        return msg;\n    let ret = "";\n    for (const split of splits) {\n        if (!split.startsWith(\':\') || !split.endsWith(\':\')) {\n            ret += split;\n            continue;\n        }\n        const name = split.replaceAll(\':\', \'\');\n        const emoji = await guild.emojis.cache.find(o => o.name === name);\n        if (!emoji) {\n            console.log(`Didn\'t find emoji ${split}`);\n            ret += split;\n            continue;\n        }\n        ret += `${emoji}`;\n    }\n    return ret;\n}\nexports.UpdateChat = {\n    run: async function (client, guild) {\n        const fetched = await client.guilds.cache.get(guild.guild_id);\n        if (!fetched) {\n            (0, logger_1.default)(`#updateChat Couldn\'t get guild ${guild.guild_id}`);\n            return;\n        }\n        let timestamp = (guild.last_chat_update === undefined ? 0 : guild.last_chat_update);\n        const clan = await clanService_1.default.getClanInformation(guild.user_uid, guild.password_hash);\n        if (!clan) {\n            (0, logger_1.default)(`#updateChat Invalid clan information`, logger_1.LoggerType.ERROR);\n            return;\n        }\n        const messages = await clanService_1.default.getClanMessages(guild.user_uid, guild.password_hash, clan.name);\n        const channel = await fetched.channels.cache.get(guild.chat_channel || "");\n        if (!channel || channel.type !== discord_js_1.ChannelType.GuildText) {\n            (0, logger_1.default)("#updateChat Couldn\'t find valid chat channel!", logger_1.LoggerType.ERROR);\n            return;\n        }\n        for (let msg of messages) {\n            if (msg.timestamp > timestamp) {\n                let processed = await processMentions(msg.content, fetched, clan.members);\n                processed = await processEmoji(processed, fetched);\n                const nickname = clan.members.find(o => o.uid === msg.uid)?.nickname || "Unkown";\n                const date = new Date(msg.timestamp * 1000);\n                await channel.send({\n                    content: `> **${nickname} ${(0, utils_1.dateToString)(date, \'Y-M-D h:m:s\')}**\\n> ${processed}`\n                });\n                timestamp = msg.timestamp;\n            }\n        }\n        guild.last_chat_update = timestamp;\n        (0, logger_1.default)(`#updateChat in ${fetched.name}`);\n    },\n    startOnInit: true,\n    repeat: true,\n    timeout: 1\n};\n\n\n//# sourceURL=webpack://borbot/./src/bot/actions/updateChat.ts?')},"./src/bot/actions/updateSchedule.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.UpdateSchedule = void 0;\nconst logger_1 = __importStar(__webpack_require__(/*! ../../shared/logger */ "./src/shared/logger.ts"));\nconst clanService_1 = __importDefault(__webpack_require__(/*! ../../services/clanService */ "./src/services/clanService.ts"));\nconst guildService_1 = __importDefault(__webpack_require__(/*! ../../services/guildService */ "./src/services/guildService.ts"));\nconst utils_1 = __webpack_require__(/*! ../../shared/utils */ "./src/shared/utils.ts");\nconst discord_js_1 = __webpack_require__(/*! discord.js */ "discord.js");\nexports.UpdateSchedule = {\n    run: async function (client, guild) {\n        const fetched = await client.guilds.cache.get(guild.guild_id);\n        if (!fetched) {\n            (0, logger_1.default)(`#updateSchedule Couldn\'t get guild with id: ${guild.guild_id}`);\n            return;\n        }\n        const schedule = await guildService_1.default.getGuildSchedule(guild.guild_id);\n        if (!schedule) {\n            (0, logger_1.default)("#updateSchedule Schedule wasn\'t setup!", logger_1.LoggerType.WARN);\n            return;\n        }\n        const channel_message_id = schedule.schedule_message_id || "";\n        const channel_id = schedule.schedule_channel || "";\n        if (!channel_id || channel_id.length === 0) {\n            (0, logger_1.default)(`#updateSchedule No schedule channel assigned`);\n            return;\n        }\n        const channel = await fetched.channels.cache.get(channel_id);\n        if (!channel || channel.type !== discord_js_1.ChannelType.GuildText) {\n            (0, logger_1.default)("#updateSchedule Couldn\'t find schedule channel!", logger_1.LoggerType.WARN);\n            return;\n        }\n        const clan = await clanService_1.default.getClanInformation(guild.user_uid, guild.password_hash);\n        if (!clan) {\n            (0, logger_1.default)(`#updateSchedule Invalid clan information`, logger_1.LoggerType.ERROR);\n            return;\n        }\n        const raid = await clanService_1.default.getClanNewRaid(guild.user_uid, guild.password_hash, clan.name);\n        const MS_IN_DAY = 86400000;\n        const cycle_end = new Date(schedule.cycle_start.getTime() + MS_IN_DAY * 9);\n        const allFightsCompleted = raid.isSuccessful && raid.isBonusSuccessful;\n        let message = `:calendar_spiral: **SCHEDULE ${(0, utils_1.dateToString)(schedule.cycle_start, \'M.D\')}-${(0, utils_1.dateToString)(cycle_end, \'M.D\')}** :calendar_spiral:\\n\\n`;\n        for (let i = 0; i < 10; ++i) {\n            const date = new Date(schedule.cycle_start.getTime() + MS_IN_DAY * i);\n            const time_difference = Date.now() - date.getTime();\n            const is_past = time_difference >= MS_IN_DAY;\n            const is_today = time_difference >= 0 && !is_past;\n            const prefix = is_past || (is_today && allFightsCompleted) ? "~~" : is_today && !allFightsCompleted ? "**" : "";\n            message += `${prefix}${(0, utils_1.dateToString)(date, \'M.D\')} -> `;\n            const entry = schedule.map.find(o => o.index === i + 1);\n            if (!entry) {\n                message += `Anyone${prefix}\\n`;\n                continue;\n            }\n            const member = clan.members.find(o => o.uid === entry.member.clan_uid);\n            if (!member) {\n                message += `Anyone${prefix}\\n`;\n                (0, logger_1.default)(`#updateSchedule Couldn\'t find clan member with uid ${entry.member.clan_uid}!`, logger_1.LoggerType.WARN);\n                continue;\n            }\n            message += `${member.nickname}${prefix}\\n`;\n        }\n        if (channel_message_id && channel_message_id.length > 0) {\n            try {\n                const fetched_message = await channel.messages.fetch(channel_message_id);\n                await fetched_message.edit(message);\n                return;\n            }\n            catch (error) {\n                (0, logger_1.default)(`No fetched message associated with id ${channel_message_id}`, logger_1.LoggerType.WARN);\n            }\n        }\n        const sent_message = await channel.send(message);\n        schedule.schedule_message_id = sent_message.id;\n        await schedule.save();\n        (0, logger_1.default)(`#updateSchedule in ${fetched.name}`);\n    },\n    startOnInit: true,\n    timeout: 5,\n    repeat: true\n};\n\n\n//# sourceURL=webpack://borbot/./src/bot/actions/updateSchedule.ts?')},"./src/bot/actions/updateUsers.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.UpdateUsers = void 0;\nconst logger_1 = __importStar(__webpack_require__(/*! ../../shared/logger */ "./src/shared/logger.ts"));\nconst utils_1 = __webpack_require__(/*! ../../shared/utils */ "./src/shared/utils.ts");\nconst clanService_1 = __importDefault(__webpack_require__(/*! ../../services/clanService */ "./src/services/clanService.ts"));\nconst guildService_1 = __importDefault(__webpack_require__(/*! ../../services/guildService */ "./src/services/guildService.ts"));\nconst discord_js_1 = __webpack_require__(/*! discord.js */ "discord.js");\nconst MILESTONES = [\n    100, 200, 300,\n    1000, 5000,\n    10000, 20000, 50000, 100000, 150000, 200000,\n    250000, 300000, 350000, 400000, 450000, 500000,\n    750000,\n    1000000\n];\nfunction getMilestoneFromZone(zone) {\n    let milestone = -1;\n    for (let i = 0; i < MILESTONES.length; ++i) {\n        if (zone < MILESTONES[i]) {\n            milestone = i;\n            break;\n        }\n    }\n    if (milestone == -1) {\n        const add = Math.floor((zone - 1000000) / 100000);\n        milestone = MILESTONES.length + add;\n    }\n    return milestone;\n}\nfunction getZoneFromMilestone(index) {\n    if (index <= 0) {\n        return 0;\n    }\n    else if (index <= MILESTONES.length) {\n        return MILESTONES[index - 1];\n    }\n    const add = index - MILESTONES.length;\n    return 1000000 + 100000 * add;\n}\nexports.UpdateUsers = {\n    timeout: 10,\n    startOnInit: true,\n    repeat: true,\n    async run(client, guild) {\n        const fetched = client.guilds.cache.get(guild.guild_id);\n        if (!fetched) {\n            (0, logger_1.default)(`#updateUsers Couldn\'t find guild ${guild.guild_id}`);\n            return;\n        }\n        const clan = await clanService_1.default.getClanInformation(guild.user_uid, guild.password_hash);\n        if (!clan) {\n            (0, logger_1.default)(`#updateUsers Invalid clan information`, logger_1.LoggerType.ERROR);\n            return;\n        }\n        const members = await guildService_1.default.getGuildConnected(guild.guild_id);\n        const fetchedMembers = await fetched.members.fetch();\n        for (const member of members) {\n            const clanMember = clan.members.find(o => o.uid === member.clan_uid);\n            if (!clanMember) {\n                (0, logger_1.default)(`#updateUsers Clan member ${member.clan_uid} doesn\'t exist!`, logger_1.LoggerType.ERROR);\n                continue;\n            }\n            const lastMilestone = member.highest_milestone || -1;\n            const currentMilestone = getMilestoneFromZone(clanMember.highestZone);\n            if (lastMilestone < currentMilestone) {\n                member.highest_milestone = currentMilestone;\n                member.save();\n                if (lastMilestone !== -1) {\n                    const channel = await client.getCachedGuildChannel(fetched, guild.milestone_channel || "");\n                    if (!channel || channel.type !== discord_js_1.ChannelType.GuildText) {\n                        (0, logger_1.default)("#updateUsers Couldn\'t find announcement channel!", logger_1.LoggerType.ERROR);\n                    }\n                    else {\n                        const prettyZone = (0, utils_1.addCommas)(getZoneFromMilestone(currentMilestone));\n                        channel.send(`**${clanMember.nickname}** just reached a new milestone of **${prettyZone}!** :crossed_swords:`);\n                    }\n                }\n            }\n            const dcMember = fetchedMembers.get(member.guild_uid);\n            if (dcMember && dcMember.manageable) {\n                dcMember.setNickname(`${clanMember.nickname} [${clanMember.level}]`);\n            }\n        }\n        (0, logger_1.default)(`#updateUsers in ${fetched.name}`);\n    }\n};\n\n\n//# sourceURL=webpack://borbot/./src/bot/actions/updateUsers.ts?')},"./src/bot/client.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst discord_js_1 = __webpack_require__(/*! discord.js */ "discord.js");\nconst actions_1 = __webpack_require__(/*! ./actions */ "./src/bot/actions.ts");\nconst commands_1 = __webpack_require__(/*! ./commands */ "./src/bot/commands.ts");\nconst guild_1 = __importDefault(__webpack_require__(/*! ../models/guild */ "./src/models/guild.ts"));\nconst logger_1 = __importStar(__webpack_require__(/*! ../shared/logger */ "./src/shared/logger.ts"));\nconst guildService_1 = __importDefault(__webpack_require__(/*! ../services/guildService */ "./src/services/guildService.ts"));\nclass Bot extends discord_js_1.Client {\n    _actions = [];\n    constructor(options) {\n        super(options);\n        this.on(\'ready\', this.onReady.bind(this));\n        this.on(\'interactionCreate\', this.onInteractionCreate.bind(this));\n        this.on(\'guildMemberRemove\', this.onGuildMemberRemove.bind(this));\n    }\n    async onReady() {\n        if (!this.user || !this.application) {\n            console.error("User or application aren\'t initialized!");\n            return;\n        }\n        try {\n            if (!this.isDevelopment) {\n                await this.user.setUsername(`Borbot ${process.env.npm_package_version}`);\n            }\n            else {\n                await this.user.setUsername(`Borbot In Development`);\n            }\n            await this.user.setAvatar(this.isDevelopment ? "https://i.imgur.com/1xMiyWX.png" : "https://i.imgur.com/eC0cR2X.png");\n        }\n        catch (error) {\n            console.warn("Couldn\'t update bot username or avatar!");\n        }\n        if (this.isDevelopment) {\n            this.user.setStatus(\'dnd\');\n        }\n        this.intializeActions(actions_1.Actions);\n    }\n    async onInteractionCreate(interaction) {\n        if (!interaction.isCommand())\n            return;\n        const cmd = commands_1.Commands.find(c => c.data.name === interaction.commandName);\n        if (!cmd) {\n            await interaction.reply({\n                content: "Couldn\'t find command runner...",\n                ephemeral: true\n            });\n            return;\n        }\n        await cmd.run(this, interaction);\n    }\n    async onGuildMemberRemove(member) {\n        try {\n            await guildService_1.default.removeGuildConnectedMember({ guild_id: member.guild.id, guild_uid: member.id });\n        }\n        catch (error) {\n            (0, logger_1.default)(`Error when removing connected member: `, error);\n        }\n    }\n    intializeActions(actions) {\n        this._actions = actions.map(o => ({\n            action: o,\n            ticks: o.startOnInit ? 0 : o.timeout\n        }));\n        const execute = () => {\n            const list = this._actions.filter(o => {\n                const shouldRun = --o.ticks <= 0;\n                if (shouldRun)\n                    o.ticks = o.action.timeout;\n                return shouldRun;\n            });\n            if (list.length === 0)\n                return;\n            guild_1.default.find().then(async (guilds) => {\n                for (const guild of guilds) {\n                    (async () => {\n                        for (const action of list) {\n                            try {\n                                await action.action.run(this, guild);\n                            }\n                            catch (error) {\n                                (0, logger_1.default)(`Error in action: ${error}`, logger_1.LoggerType.ERROR);\n                            }\n                        }\n                        guild.save();\n                    })();\n                }\n            }).catch(error => (0, logger_1.default)(`ActionRunner: Couldn\'t fetch guilds, error: ${error}`, logger_1.LoggerType.ERROR));\n        };\n        execute();\n        setInterval(execute, 60000);\n    }\n    getCachedGuild(id) {\n        const cached = this.guilds.cache.get(id);\n        if (!cached)\n            return null;\n        return cached;\n    }\n    async getCachedGuildMembers(id, fetch = true) {\n        const guild = this.getCachedGuild(id);\n        if (!guild)\n            return null;\n        if (fetch)\n            await guild.members.fetch();\n        return guild.members.cache;\n    }\n    async getCachedGuildMember(guild_id, member_id, fetch = true) {\n        const guild = this.getCachedGuild(guild_id);\n        if (!guild)\n            return null;\n        if (fetch)\n            await guild.members.fetch();\n        return guild.members.cache.get(member_id);\n    }\n    async getCachedGuildChannels(id, fetch = false) {\n        const guild = this.getCachedGuild(id);\n        if (!guild)\n            return null;\n        if (fetch)\n            await guild.channels.fetch();\n        return guild.channels.cache;\n    }\n    async getCachedGuildChannel(guild, channel_id, fetch = false) {\n        if (fetch)\n            await guild.channels.fetch();\n        return guild.channels.cache.get(channel_id);\n    }\n    async existsCachedGuildChannel(guild, channel_id, fetch = false) {\n        if (fetch)\n            await guild.channels.fetch();\n        return guild.channels.cache.has(channel_id);\n    }\n    async getCachedGuildRoles(id, fetch = false) {\n        const guild = this.getCachedGuild(id);\n        if (!guild)\n            return null;\n        if (fetch)\n            await guild.roles.fetch();\n        return guild.roles.cache;\n    }\n    async existsCachedGuildRole(guild, role_id, fetch = false) {\n        if (fetch)\n            await guild.roles.fetch();\n        return guild.roles.cache.has(role_id);\n    }\n    get isDevelopment() {\n        return "development" != "production";\n    }\n}\nexports["default"] = Bot;\n\n\n//# sourceURL=webpack://borbot/./src/bot/client.ts?')},"./src/bot/commands.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Commands = void 0;\nconst clan_1 = __webpack_require__(/*! ./commands/clan */ "./src/bot/commands/clan.ts");\nconst profile_1 = __webpack_require__(/*! ./commands/profile */ "./src/bot/commands/profile.ts");\nexports.Commands = [\n    clan_1.Clan,\n    profile_1.Profile\n];\n\n\n//# sourceURL=webpack://borbot/./src/bot/commands.ts?')},"./src/bot/commands/clan.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Clan = void 0;\nconst builders_1 = __webpack_require__(/*! @discordjs/builders */ "@discordjs/builders");\nconst text_table_1 = __importDefault(__webpack_require__(/*! text-table */ "text-table"));\nconst utils_1 = __webpack_require__(/*! ../../shared/utils */ "./src/shared/utils.ts");\nconst clanService_1 = __importStar(__webpack_require__(/*! ../../services/clanService */ "./src/services/clanService.ts"));\nconst guildService_1 = __importDefault(__webpack_require__(/*! ../../services/guildService */ "./src/services/guildService.ts"));\nexports.Clan = {\n    data: new builders_1.SlashCommandBuilder()\n        .setName(\'clan\')\n        .setDescription(\'Replies with clan info!\'),\n    run: async (client, interaction) => {\n        const guildId = interaction.guildId;\n        const guild = await guildService_1.default.getGuild(guildId);\n        if (!guild) {\n            await interaction.reply({\n                content: "Guild isn\'t setup! Contact the admin.",\n                ephemeral: true\n            });\n            return;\n        }\n        const clan = await clanService_1.default.getClanInformation(guild.user_uid, guild.password_hash);\n        if (!clan) {\n            await interaction.reply({\n                content: "Error retreiving clan data! Contact the admin.",\n                ephemeral: true\n            });\n            return;\n        }\n        let response = `**${clan.name}**\\n**Immortals** [New: ${clan.currentNewRaidLevel - 1}, Legacy: ${clan.currentRaidLevel}]\\n`;\n        response += "\\`\\`\\`";\n        const formatted = clan.members\n            .sort((a, b) => b.highestZone - a.highestZone)\n            .map(x => [x.nickname, (0, utils_1.addCommas)(x.highestZone), clanService_1.ClanClass[x.class], x.level.toString()]);\n        response += (0, text_table_1.default)([[\'Name\', \'Highest Zone\', \'Class\', \'Level\'], []].concat(formatted), { align: [\'l\', \'l\', \'l\', \'r\'] });\n        response += \'\\`\\`\\`\';\n        await interaction.reply(response);\n    }\n};\n\n\n//# sourceURL=webpack://borbot/./src/bot/commands/clan.ts?')},"./src/bot/commands/profile.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Profile = void 0;\nconst builders_1 = __webpack_require__(/*! @discordjs/builders */ "@discordjs/builders");\nconst logger_1 = __importStar(__webpack_require__(/*! ../../shared/logger */ "./src/shared/logger.ts"));\nconst utils_1 = __webpack_require__(/*! ../../shared/utils */ "./src/shared/utils.ts");\nconst clanService_1 = __importStar(__webpack_require__(/*! ../../services/clanService */ "./src/services/clanService.ts"));\nconst guildService_1 = __importDefault(__webpack_require__(/*! ../../services/guildService */ "./src/services/guildService.ts"));\nconst discord_js_1 = __webpack_require__(/*! discord.js */ "discord.js");\nexports.Profile = {\n    data: new builders_1.SlashCommandBuilder()\n        .setName("profile")\n        .setDescription("Show beautiful profile from clicker heroes user data!")\n        .addUserOption(input => input\n        .setName("user")\n        .setDescription("Optional: Select user you would like to see")\n        .setRequired(false)),\n    run: async function (client, interaction) {\n        const guildId = interaction.guildId;\n        const guild = await guildService_1.default.getGuild(guildId);\n        if (!guild) {\n            await interaction.reply({\n                content: "Guild isn\'t setup! Contact the administrator.",\n                ephemeral: true\n            });\n            return;\n        }\n        const clan = await clanService_1.default.getClanInformation(guild.user_uid, guild.password_hash);\n        if (!clan) {\n            await interaction.reply({\n                content: "Couldn\'t get clan information! Contact the administrator.",\n                ephemeral: true\n            });\n            return;\n        }\n        const user = interaction.options.getUser("user", false) || interaction.user;\n        const connected = await guildService_1.default.getGuildConnectedMember({ guild_id: guildId, guild_uid: user.id });\n        if (!connected) {\n            (0, logger_1.default)(`/profile Couldn\'t find connected member with guild uid: ${user.id}`, logger_1.LoggerType.ERROR);\n            await interaction.reply({\n                content: "Selected user is not connected! Contact the guild administrator :)",\n                ephemeral: true\n            });\n            return;\n        }\n        const member = clan.members.find(o => o.uid === connected.clan_uid);\n        if (!member) {\n            (0, logger_1.default)(`/profile Couldn\'t find clan member with guild uid: ${user.id}`, logger_1.LoggerType.ERROR);\n            await interaction.reply({\n                content: "You\'re not a clan member! Contact the guild administrator :)",\n                ephemeral: true\n            });\n            return;\n        }\n        const embed = new discord_js_1.EmbedBuilder()\n            .setColor("#5E81AC")\n            .setTitle(`Profile`)\n            .setAuthor({ name: member.nickname, iconURL: (user.avatarURL() || "") })\n            .addFields({ name: "Class", value: clanService_1.ClanClass[member.class], inline: true }, { name: "Level", value: member.level.toString(), inline: true }, { name: "Highest Zone", value: (0, utils_1.addCommas)(member.highestZone), inline: true })\n            .setImage(\'https://i.imgur.com/glzDw4P.gif\')\n            .setFooter({ text: "Composed by Mighty Borb", iconURL: client.user?.avatarURL() || "" });\n        switch (member.class) {\n            case clanService_1.ClanClass.Mage:\n                embed.setThumbnail("https://i.imgur.com/WR0ZE4i.png");\n                break;\n            case clanService_1.ClanClass.Priest:\n                embed.setThumbnail("https://i.imgur.com/dSjBg7M.png");\n                break;\n            case clanService_1.ClanClass.Rogue:\n                embed.setThumbnail("https://i.imgur.com/4aGoDnB.png");\n                break;\n            default: break;\n        }\n        await interaction.reply({ embeds: [embed] });\n    }\n};\n\n\n//# sourceURL=webpack://borbot/./src/bot/commands/profile.ts?')},"./src/index.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n__webpack_require__(/*! dotenv/config */ "dotenv/config");\nconst discord_js_1 = __webpack_require__(/*! discord.js */ "discord.js");\nconst client_1 = __importDefault(__webpack_require__(/*! ./bot/client */ "./src/bot/client.ts"));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));\nconst logger_1 = __importStar(__webpack_require__(/*! ./shared/logger */ "./src/shared/logger.ts"));\nconst server_1 = __importDefault(__webpack_require__(/*! ./server/server */ "./src/server/server.ts"));\nmongoose_1.default.connect(process.env.MONGODB_URI).then(async () => {\n    (0, logger_1.default)("MongoDB Conncted!");\n    (0, logger_1.default)("Bot is starting...");\n    const client = new client_1.default({\n        intents: [\n            discord_js_1.GatewayIntentBits.Guilds,\n            discord_js_1.GatewayIntentBits.GuildMessages,\n            discord_js_1.GatewayIntentBits.GuildEmojisAndStickers,\n            discord_js_1.GatewayIntentBits.GuildMembers\n        ]\n    });\n    await client.login(process.env.BOT_TOKEN);\n    const api = (0, server_1.default)(client);\n    api.listen(3010, () => {\n        (0, logger_1.default)("Started REST API on port 3010.");\n    });\n}).catch(error => (0, logger_1.default)(error, logger_1.LoggerType.ERROR));\n\n\n//# sourceURL=webpack://borbot/./src/index.ts?')},"./src/models/guild.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));\nconst GuildSchema = new mongoose_1.default.Schema({\n    guild_id: { type: String, required: true },\n    user_uid: { type: String, required: true },\n    password_hash: { type: String, required: true },\n    raid_announcement_channel: { type: String, required: false },\n    raid_fight_role: { type: String, required: false },\n    raid_claim_role: { type: String, required: false },\n    clan_chat_channel: { type: String, required: false },\n    last_chat_update: { type: Number, required: false },\n    remind_channel: { type: String, required: false },\n    last_reminded: { type: Date, required: false },\n    milestone_channel: { type: String, required: false },\n    chat_channel: { type: String, required: false },\n    schedule: { type: mongoose_1.default.Schema.Types.ObjectId, ref: \'Schedule\', required: false }\n});\nconst GuildModel = mongoose_1.default.model(\'Guild\', GuildSchema);\nexports["default"] = GuildModel;\n\n\n//# sourceURL=webpack://borbot/./src/models/guild.ts?')},"./src/models/member.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));\nconst MemberSchema = new mongoose_1.default.Schema({\n    guild_id: { type: String, required: true },\n    guild_uid: { type: String, required: true },\n    clan_uid: { type: String, required: true },\n    highest_milestone: { type: Number, required: false }\n});\nconst MemberModel = mongoose_1.default.model(\'Member\', MemberSchema);\nexports["default"] = MemberModel;\n\n\n//# sourceURL=webpack://borbot/./src/models/member.ts?')},"./src/models/schedule.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));\nconst ScheduleSchema = new mongoose_1.default.Schema({\n    cycle_start: { type: Date, required: true, default: new Date() },\n    length: { type: Number, required: true, default: 10 },\n    last_checked: { type: Date, required: false },\n    loggedRaidSuccess: { type: Boolean, required: false },\n    loggedBonusRaidAvailable: { type: Boolean, required: false },\n    loggedBonusRaidSuccess: { type: Boolean, required: false },\n    schedule_channel: { type: String, required: false },\n    schedule_message_id: { type: String, required: false },\n    map: {\n        type: [{\n                member: {\n                    type: mongoose_1.default.Schema.Types.ObjectId,\n                    ref: \'Member\'\n                },\n                index: Number\n            }],\n        required: true,\n        default: []\n    }\n});\nconst ScheduleModel = mongoose_1.default.model(\'Schedule\', ScheduleSchema);\nexports["default"] = ScheduleModel;\n\n\n//# sourceURL=webpack://borbot/./src/models/schedule.ts?')},"./src/models/user.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));\nconst UserSchema = new mongoose_1.default.Schema({\n    id: { type: String, required: true },\n    token: { type: String, required: true },\n    guilds: {\n        type: [{\n                id: String,\n                name: String,\n                icon: String,\n                permissions: String,\n                isAdmin: Boolean\n            }],\n        required: true,\n        default: []\n    },\n    last_update_guilds: { type: Number, required: false }\n});\nconst UserModel = mongoose_1.default.model(\'User\', UserSchema);\nexports["default"] = UserModel;\n\n\n//# sourceURL=webpack://borbot/./src/models/user.ts?')},"./src/server/controllers/auth.controller.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst discord_1 = __importDefault(__webpack_require__(/*! ../../api/discord */ "./src/api/discord.ts"));\nconst userService_1 = __importDefault(__webpack_require__(/*! ../../services/userService */ "./src/services/userService.ts"));\nconst code_1 = __importDefault(__webpack_require__(/*! ../../shared/code */ "./src/shared/code.ts"));\nconst utils_1 = __webpack_require__(/*! ../../shared/utils */ "./src/shared/utils.ts");\nconst AuthController = {\n    auth_login: async function (req, res) {\n        const clientID = process.env.APP_ID;\n        const clientSecret = process.env.APP_SECRET;\n        const clientCode = req.body.code;\n        try {\n            const oauth = await discord_1.default.getAuthToken(clientID, clientSecret, clientCode);\n            const user = await discord_1.default.getUserInformation(oauth.access_token);\n            await userService_1.default.createOrUpdateUser({ id: user.id, token: oauth.access_token });\n            const jwtToken = (0, utils_1.generateAccessToken)(user.id);\n            res.cookie(\'token\', jwtToken).send({ code: code_1.default.OK, msg: "OK" });\n        }\n        catch (error) {\n            console.log(error);\n            res.status(error.status);\n            res.send({ code: error.data.code, message: error.data.message });\n        }\n    },\n    auth_logout: async function (req, res) {\n        res.clearCookie(\'token\').send({ code: code_1.default.OK, msg: "OK" });\n    },\n    discord_auth_callback: function (req, res) {\n        const code = req.query.code;\n        res.set(\'Content-Type\', \'text/html\');\n        res.send(Buffer.from(`<script>window.opener.postMessage("${code}", "http://localhost:3000");window.close();<\/script>`));\n    },\n    discord_auth_bot_callback: function (req, res) {\n        res.set(\'Content-Type\', \'text/html\');\n        res.send(Buffer.from(`<script>window.opener.postMessage("OK", "http://localhost:3000");window.close();<\/script>`));\n    },\n};\nexports["default"] = AuthController;\n\n\n//# sourceURL=webpack://borbot/./src/server/controllers/auth.controller.ts?')},"./src/server/controllers/guild.controller.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst utils_1 = __webpack_require__(/*! ../../shared/utils */ "./src/shared/utils.ts");\nconst guildService_1 = __importDefault(__webpack_require__(/*! ../../services/guildService */ "./src/services/guildService.ts"));\nconst code_1 = __importDefault(__webpack_require__(/*! ../../shared/code */ "./src/shared/code.ts"));\nconst clanService_1 = __importDefault(__webpack_require__(/*! ../../services/clanService */ "./src/services/clanService.ts"));\nconst discord_js_1 = __webpack_require__(/*! discord.js */ "discord.js");\nconst GuildController = {\n    guild_get: async function (req, res, next) {\n        const bot = req.app.get(\'bot\');\n        const userGuild = req.guild;\n        const dbGuild = await guildService_1.default.getGuild(userGuild.id);\n        const is_setup = dbGuild !== null;\n        const is_joined = bot.guilds.cache.get(userGuild.id) !== undefined;\n        res.send({\n            id: userGuild.id,\n            name: userGuild.name,\n            icon: userGuild.icon,\n            permissions: userGuild.permissions,\n            isAdmin: userGuild.isAdmin,\n            is_setup: is_setup,\n            is_joined: is_joined,\n            raid_announcement_channel: dbGuild?.raid_announcement_channel,\n            raid_fight_role: dbGuild?.raid_fight_role,\n            raid_claim_role: dbGuild?.raid_claim_role,\n            remind_channel: dbGuild?.remind_channel,\n            milestone_channel: dbGuild?.milestone_channel,\n            chat_channel: dbGuild?.chat_channel\n        });\n    },\n    guild_patch: async function (req, res, next) {\n        const GUILD_ID = req.params.id;\n        const bot = req.app.get(\'bot\');\n        const params = {\n            raid_announcement_channel: req.body.raid_announcement_channel,\n            raid_fight_role: req.body.raid_fight_role,\n            raid_claim_role: req.body.raid_claim_role,\n            remind_channel: req.body.remind_channel,\n            milestone_channel: req.body.milestone_channel,\n            chat_channel: req.body.chat_channel\n        };\n        try {\n            const cached = bot.getCachedGuild(GUILD_ID);\n            if (!cached) {\n                next({ code: code_1.default.GUILD_REQUIRES_BOT });\n                return;\n            }\n            if (params.raid_announcement_channel && !await bot.existsCachedGuildChannel(cached, params.raid_announcement_channel)) {\n                return res.status(400).send({\n                    code: code_1.default.BAD_REQUEST,\n                    message: "Invalid raid announcement channel"\n                });\n            }\n            if (params.raid_fight_role && !await bot.existsCachedGuildRole(cached, params.raid_fight_role)) {\n                return res.status(400).send({\n                    code: code_1.default.BAD_REQUEST,\n                    message: "Invalid raid fight role"\n                });\n            }\n            if (params.raid_claim_role && !await bot.existsCachedGuildRole(cached, params.raid_claim_role)) {\n                return res.status(400).send({\n                    code: code_1.default.BAD_REQUEST,\n                    message: "Invalid raid claim role"\n                });\n            }\n            if (params.remind_channel && !await bot.existsCachedGuildChannel(cached, params.remind_channel)) {\n                return res.status(400).send({\n                    code: code_1.default.BAD_REQUEST,\n                    message: "Invalid remind channel"\n                });\n            }\n            if (params.milestone_channel && !await bot.existsCachedGuildChannel(cached, params.milestone_channel)) {\n                return res.status(400).send({\n                    code: code_1.default.BAD_REQUEST,\n                    message: "Invalid milestone channel"\n                });\n            }\n            if (params.chat_channel && !await bot.existsCachedGuildChannel(cached, params.chat_channel)) {\n                return res.status(400).send({\n                    code: code_1.default.BAD_REQUEST,\n                    message: "Invalid chat channel"\n                });\n            }\n            const result = await guildService_1.default.updateGuild(GUILD_ID, params);\n            if (!result) {\n                next({ code: code_1.default.GUILD_NOT_SETUP });\n                return;\n            }\n            res.send({ code: code_1.default.OK });\n        }\n        catch (error) {\n            next(error);\n        }\n    },\n    guild_post: async function (req, res, next) {\n        const GUILD_ID = req.params.id;\n        const bot = req.app.get(\'bot\');\n        const { uid: USER_ID, pwd: USER_PWD } = req.body;\n        try {\n            const cached = bot.getCachedGuild(GUILD_ID);\n            if (!cached) {\n                next({ code: code_1.default.GUILD_REQUIRES_BOT });\n                return;\n            }\n            const isSetup = await guildService_1.default.isGuildSetup(GUILD_ID);\n            if (isSetup) {\n                next({ code: code_1.default.GUILD_ALREADY_SETUP });\n                return;\n            }\n            const clan = await clanService_1.default.getClanInformation(USER_ID, USER_PWD);\n            if (!clan) {\n                next({ code: code_1.default.CLAN_INVALID_CREDENTIALS });\n                return;\n            }\n            await guildService_1.default.addGuild(GUILD_ID, USER_ID, USER_PWD);\n            res.send({ code: code_1.default.OK });\n        }\n        catch (error) {\n            next(error);\n        }\n    },\n    guild_delete: async function (req, res, next) {\n        const GUILD_ID = req.params.id;\n        try {\n            const result = await guildService_1.default.removeGuild(GUILD_ID);\n            if (!result) {\n                next({ code: code_1.default.GUILD_NOT_SETUP });\n                return;\n            }\n            res.send({ code: code_1.default.OK });\n        }\n        catch (error) {\n            next(error);\n        }\n    },\n    guild_clan_members_get: async function (req, res, next) {\n        const GUILD_ID = req.params.id;\n        try {\n            const guild = await guildService_1.default.getGuild(GUILD_ID);\n            if (!guild) {\n                next({ code: code_1.default.GUILD_NOT_SETUP });\n                return;\n            }\n            const clan = await clanService_1.default.getClanInformation(guild.user_uid, guild.password_hash);\n            if (!clan) {\n                next({ code: code_1.default.CLAN_INVALID_CREDENTIALS });\n                return;\n            }\n            res.send(clan.members);\n        }\n        catch (error) {\n            next(error);\n        }\n    },\n    guild_members_get: async function (req, res, next) {\n        const GUILD_ID = req.params.id;\n        const bot = req.app.get(\'bot\');\n        try {\n            const members = await bot.getCachedGuildMembers(GUILD_ID);\n            if (!members) {\n                next({ code: code_1.default.GUILD_REQUIRES_BOT });\n                return;\n            }\n            const list = [];\n            for (const [, member] of members) {\n                list.push({\n                    id: member.user.id,\n                    discriminator: member.user.discriminator,\n                    username: member.user.username,\n                    avatar: (0, utils_1.getUserIconURL)(member.user, 48),\n                    nickname: member.nickname,\n                    isBot: member.user.bot || false\n                });\n            }\n            res.send(list);\n        }\n        catch (error) {\n            next(error);\n        }\n    },\n    guild_channels_get: async function (req, res, next) {\n        const GUILD_ID = req.params.id;\n        const bot = req.app.get(\'bot\');\n        try {\n            const channels = await bot.getCachedGuildChannels(GUILD_ID);\n            if (!channels) {\n                next({ code: code_1.default.GUILD_REQUIRES_BOT });\n                return;\n            }\n            const list = [];\n            for (const [, channel] of channels) {\n                if (!channel.parentId || channel.type !== discord_js_1.ChannelType.GuildText)\n                    continue;\n                list.push({\n                    id: channel.id,\n                    name: channel.name\n                });\n            }\n            res.send(list);\n        }\n        catch (error) {\n            next(error);\n        }\n    },\n    guild_roles_get: async function (req, res, next) {\n        const GUILD_ID = req.params.id;\n        const bot = req.app.get(\'bot\');\n        try {\n            const roles = await bot.getCachedGuildRoles(GUILD_ID);\n            if (!roles) {\n                next({ code: code_1.default.GUILD_REQUIRES_BOT });\n                return;\n            }\n            const list = [];\n            for (const [, role] of roles) {\n                list.push({\n                    id: role.id,\n                    name: role.name\n                });\n            }\n            res.send(list);\n        }\n        catch (error) {\n            next(error);\n        }\n    },\n    guild_connected_get: async function (req, res, next) {\n        const GUILD_ID = req.params.id;\n        try {\n            const isSetup = await guildService_1.default.isGuildSetup(GUILD_ID);\n            if (!isSetup) {\n                next({ code: code_1.default.GUILD_NOT_SETUP });\n                return;\n            }\n            const members = await guildService_1.default.getGuildConnected(GUILD_ID);\n            const list = members.map(o => ({\n                guild_uid: o.guild_uid,\n                clan_uid: o.clan_uid\n            }));\n            res.send(list);\n        }\n        catch (error) {\n            next(error);\n        }\n    },\n    guild_connected_post: async function (req, res, next) {\n        const GUILD_ID = req.params.id;\n        const bot = req.app.get(\'bot\');\n        const data = req.body.data;\n        if (!data) {\n            res.status(400).send({\n                code: code_1.default.BAD_REQUEST,\n                message: "List of connected members required."\n            });\n            return;\n        }\n        try {\n            const guild = await guildService_1.default.getGuild(GUILD_ID);\n            if (!guild) {\n                next({ code: code_1.default.GUILD_NOT_SETUP });\n                return;\n            }\n            const members = await bot.getCachedGuildMembers(GUILD_ID);\n            if (!members) {\n                next({ code: code_1.default.GUILD_REQUIRES_BOT });\n                return;\n            }\n            const clan = await clanService_1.default.getClanInformation(guild.user_uid, guild.password_hash);\n            if (!clan) {\n                next({ code: code_1.default.CLAN_INVALID_CREDENTIALS });\n                return;\n            }\n            const list = [];\n            for (const entry of data) {\n                const isInClan = clan.members.find(o => o.uid === entry.clan_uid) !== undefined;\n                const isInGuild = entry.guild_uid === \'\' || members.find(o => o.id === entry.guild_uid) !== undefined;\n                if (isInClan && isInGuild) {\n                    list.push(entry);\n                }\n                else {\n                    res.send(400).send({\n                        code: code_1.default.BAD_REQUEST,\n                        msg: `Invalid entry in list (clan uid: ${entry.clan_uid}, guild uid: ${entry.guild_uid})`\n                    });\n                    return;\n                }\n            }\n            await guildService_1.default.updateGuildConnected(GUILD_ID, list);\n            res.send({ code: code_1.default.OK });\n        }\n        catch (error) {\n            next(error);\n        }\n    },\n    guild_schedule_get: async function (req, res, next) {\n        const GUILD_ID = req.params.id;\n        try {\n            const schedule = await guildService_1.default.getGuildSchedule(GUILD_ID);\n            if (!schedule) {\n                next({ code: code_1.default.GUILD_NOT_SETUP });\n                return;\n            }\n            const data = {\n                cycle_start: schedule.cycle_start,\n                entries: [],\n                channel: schedule.schedule_channel\n            };\n            for (let i = 1; i <= 10; ++i) {\n                const entry = schedule.map.find(o => o.index == i);\n                data.entries.push({ uid: entry?.member.guild_uid || \'\', index: i });\n            }\n            res.send(data);\n        }\n        catch (error) {\n            next(error);\n        }\n    },\n    guild_schedule_post: async function (req, res, next) {\n        const GUILD_ID = req.params.id;\n        const bot = req.app.get(\'bot\');\n        const data = req.body.list;\n        if (!data) {\n            res.status(400).send({\n                code: code_1.default.BAD_REQUEST,\n                message: "List of schedule entries required."\n            });\n            return;\n        }\n        const schedule = {\n            cycle_start: new Date(req.body.cycle_start) || undefined,\n            entries: [],\n            channel: req.body.schedule_channel || undefined\n        };\n        try {\n            const cached = await bot.getCachedGuild(GUILD_ID);\n            if (!cached) {\n                next({ code: code_1.default.GUILD_REQUIRES_BOT });\n                return;\n            }\n            if (schedule.channel) {\n                const channel = await bot.getCachedGuildChannel(cached, schedule.channel);\n                if (!channel) {\n                    res.status(400).send({\n                        code: code_1.default.BAD_REQUEST,\n                        message: "Invalid channel parameter"\n                    });\n                    return;\n                }\n            }\n            const list = [];\n            for (const entry of data) {\n                const member = await guildService_1.default.getGuildConnectedMember({ guild_id: GUILD_ID, guild_uid: entry.uid });\n                const isIndexValid = entry.index >= 1 && entry.index <= 10;\n                if (entry.uid === \'\' && isIndexValid) {\n                    list.push({ index: entry.index });\n                    continue;\n                }\n                if (member && isIndexValid) {\n                    list.push({ index: entry.index, member: member });\n                }\n                else {\n                    res.status(400).send({\n                        code: code_1.default.BAD_REQUEST,\n                        msg: `Invalid entry in list (index: ${entry.index}, uid: ${entry.uid}`\n                    });\n                    return;\n                }\n            }\n            schedule.entries = list;\n            const result = await guildService_1.default.updateGuildSchedule(GUILD_ID, schedule);\n            if (!result) {\n                next({ code: code_1.default.GUILD_NOT_SETUP });\n                return;\n            }\n            res.send({ code: code_1.default.OK });\n        }\n        catch (error) {\n            next(error);\n        }\n    }\n};\nexports["default"] = GuildController;\n\n\n//# sourceURL=webpack://borbot/./src/server/controllers/guild.controller.ts?')},"./src/server/controllers/user.controller.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst discord_1 = __importDefault(__webpack_require__(/*! ../../api/discord */ "./src/api/discord.ts"));\nconst userService_1 = __importDefault(__webpack_require__(/*! ../../services/userService */ "./src/services/userService.ts"));\nconst code_1 = __importDefault(__webpack_require__(/*! ../../shared/code */ "./src/shared/code.ts"));\nconst UserController = {\n    async user_get(req, res, next) {\n        const user = req.user;\n        try {\n            const info = await discord_1.default.getUserInformation(user.token);\n            res.send({\n                id: user.id,\n                avatar: info.avatar,\n                discriminator: info.discriminator,\n                username: info.username,\n                guilds: user.guilds || []\n            });\n        }\n        catch (error) {\n            next(error);\n        }\n    },\n    async user_guilds_get(req, res, next) {\n        const user = req.user;\n        try {\n            const guilds = await userService_1.default.getUserUpdatedGuilds(user);\n            res.send(guilds);\n        }\n        catch (error) {\n            if (error.code === code_1.default.USER_NOT_REGISTERED) {\n                res.status(401).send(error);\n                return;\n            }\n            next(error);\n        }\n    }\n};\nexports["default"] = UserController;\n\n\n//# sourceURL=webpack://borbot/./src/server/controllers/user.controller.ts?')},"./src/server/handlers/error.handler.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst code_1 = __importStar(__webpack_require__(/*! ../../shared/code */ "./src/shared/code.ts"));\nconst logger_1 = __importStar(__webpack_require__(/*! ../../shared/logger */ "./src/shared/logger.ts"));\nfunction ErrorHandler(err, req, res, next) {\n    if (err.code === undefined) {\n        (0, logger_1.default)(`Unknown error: ${err.message}`, logger_1.LoggerType.ERROR);\n        res.status(500).send({ code: -1, message: \'Unkown error\' });\n        return;\n    }\n    else if (err.code === code_1.default.DISCORD_API_ERROR) {\n        (0, logger_1.default)(`Discord call failed with status ${err.status}, path: ${err.path}, message: ${err.data.message}`, logger_1.LoggerType.ERROR);\n        if (err.status === 401) {\n            res.status(401).send({ code: code_1.default.DISCORD_INVALID_TOKEN, message: "Invalid token" });\n            return;\n        }\n        else if (err.status == 429) {\n            res.status(429).send({ code: code_1.default.DISCORD_RATE_LIMIT, message: "You reached discord rate limit for this call" });\n        }\n    }\n    else if (err.code === code_1.default.NO_RESPONSE) {\n        (0, logger_1.default)(`No reponse from discord servers`, logger_1.LoggerType.ERROR);\n        res.status(504).send({ code: code_1.default.NO_RESPONSE, message: "Didn\'t receive any reponse from the server" });\n    }\n    else if (err.code === code_1.default.INTERNAL_SERVER_ERROR) {\n        (0, logger_1.default)(`Internal error: ${err.message}`, logger_1.LoggerType.ERROR);\n        res.status(500).send({ code: code_1.default.INTERNAL_SERVER_ERROR, message: "Internal server error" });\n    }\n    else {\n        res.status(404).send({ code: err.code, message: code_1.CodeMessage[err.code] || \'\' });\n    }\n}\n;\nexports["default"] = ErrorHandler;\n\n\n//# sourceURL=webpack://borbot/./src/server/handlers/error.handler.ts?')},"./src/server/middlewares/authenticateUser.middleware.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst userService_1 = __importDefault(__webpack_require__(/*! ../../services/userService */ "./src/services/userService.ts"));\nconst code_1 = __importDefault(__webpack_require__(/*! ../../shared/code */ "./src/shared/code.ts"));\nconst utils_1 = __webpack_require__(/*! ../../shared/utils */ "./src/shared/utils.ts");\nasync function AuthenticateUser(req, res, next) {\n    const TOKEN = req.headers.authorization;\n    if (!TOKEN) {\n        res.status(401).send({ code: code_1.default.USER_NO_TOKEN, message: "Path requires authentication" });\n        return;\n    }\n    try {\n        const payload = await (0, utils_1.decryptAccessToken)(TOKEN);\n        const user = await userService_1.default.getUser(payload.uid);\n        if (!user) {\n            next({ code: code_1.default.USER_NOT_REGISTERED });\n            return;\n        }\n        req.user = user;\n        next();\n    }\n    catch (error) {\n        if (error.code === code_1.default.USER_NOT_REGISTERED) {\n            res.status(401).send(error);\n            return;\n        }\n        next(error);\n    }\n}\nexports["default"] = AuthenticateUser;\n\n\n//# sourceURL=webpack://borbot/./src/server/middlewares/authenticateUser.middleware.ts?')},"./src/server/middlewares/isInGuild.middleware.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst userService_1 = __importDefault(__webpack_require__(/*! ../../services/userService */ "./src/services/userService.ts"));\nconst code_1 = __importDefault(__webpack_require__(/*! ../../shared/code */ "./src/shared/code.ts"));\nasync function IsInGuild(req, res, next) {\n    const guild_id = req.params.id;\n    const user = req.user;\n    try {\n        const guilds = await userService_1.default.getUserUpdatedGuilds(user);\n        if (!guilds) {\n            return res.status(403).send({\n                code: code_1.default.USER_NOT_REGISTERED,\n                message: `Invalid user`\n            });\n        }\n        const guild = guilds.find(o => o.id === guild_id);\n        if (!guild) {\n            res.status(404).send({ code: code_1.default.USER_NOT_IN_GUILD, message: "Not in the guild" });\n            return;\n        }\n        else if (!guild.isAdmin) {\n            res.status(404).send({ code: code_1.default.USER_NOT_AN_ADMIN, message: "Required admin permissions" });\n            return;\n        }\n        req.guild = guild;\n        next();\n    }\n    catch (error) {\n        if (error.code === code_1.default.USER_NOT_REGISTERED) {\n            res.status(401).send(error);\n            return;\n        }\n        next(error);\n    }\n}\nexports["default"] = IsInGuild;\n\n\n//# sourceURL=webpack://borbot/./src/server/middlewares/isInGuild.middleware.ts?')},"./src/server/routes/auth.router.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst express_1 = __webpack_require__(/*! express */ "express");\nconst auth_controller_1 = __importDefault(__webpack_require__(/*! ../controllers/auth.controller */ "./src/server/controllers/auth.controller.ts"));\nconst AuthRouter = (0, express_1.Router)();\nAuthRouter.get(\'/\', auth_controller_1.default.discord_auth_callback);\nAuthRouter.get(\'/back\', auth_controller_1.default.discord_auth_bot_callback);\nAuthRouter.post(\'/login\', auth_controller_1.default.auth_login);\nAuthRouter.post(\'/logout\', auth_controller_1.default.auth_logout);\nexports["default"] = AuthRouter;\n\n\n//# sourceURL=webpack://borbot/./src/server/routes/auth.router.ts?')},"./src/server/routes/guild.router.ts":function(__unused_webpack_module,exports,__webpack_require__){eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst express_1 = __webpack_require__(/*! express */ \"express\");\nconst guild_controller_1 = __importDefault(__webpack_require__(/*! ../controllers/guild.controller */ \"./src/server/controllers/guild.controller.ts\"));\nconst authenticateUser_middleware_1 = __importDefault(__webpack_require__(/*! ../middlewares/authenticateUser.middleware */ \"./src/server/middlewares/authenticateUser.middleware.ts\"));\nconst isInGuild_middleware_1 = __importDefault(__webpack_require__(/*! ../middlewares/isInGuild.middleware */ \"./src/server/middlewares/isInGuild.middleware.ts\"));\nconst GuildRouter = (0, express_1.Router)();\nGuildRouter.get('/:id', authenticateUser_middleware_1.default, isInGuild_middleware_1.default, guild_controller_1.default.guild_get);\nGuildRouter.post('/:id', authenticateUser_middleware_1.default, isInGuild_middleware_1.default, guild_controller_1.default.guild_post);\nGuildRouter.patch('/:id', authenticateUser_middleware_1.default, isInGuild_middleware_1.default, guild_controller_1.default.guild_patch);\nGuildRouter.delete('/:id', authenticateUser_middleware_1.default, isInGuild_middleware_1.default, guild_controller_1.default.guild_delete);\nGuildRouter.get('/:id/clan/members', authenticateUser_middleware_1.default, isInGuild_middleware_1.default, guild_controller_1.default.guild_clan_members_get);\nGuildRouter.get('/:id/members', authenticateUser_middleware_1.default, isInGuild_middleware_1.default, guild_controller_1.default.guild_members_get);\nGuildRouter.get('/:id/channels', authenticateUser_middleware_1.default, isInGuild_middleware_1.default, guild_controller_1.default.guild_channels_get);\nGuildRouter.get('/:id/roles', authenticateUser_middleware_1.default, isInGuild_middleware_1.default, guild_controller_1.default.guild_roles_get);\nGuildRouter.get('/:id/connected', authenticateUser_middleware_1.default, isInGuild_middleware_1.default, guild_controller_1.default.guild_connected_get);\nGuildRouter.post('/:id/connected', authenticateUser_middleware_1.default, isInGuild_middleware_1.default, guild_controller_1.default.guild_connected_post);\nGuildRouter.get('/:id/schedule', authenticateUser_middleware_1.default, isInGuild_middleware_1.default, guild_controller_1.default.guild_schedule_get);\nGuildRouter.post('/:id/schedule', authenticateUser_middleware_1.default, isInGuild_middleware_1.default, guild_controller_1.default.guild_schedule_post);\nexports[\"default\"] = GuildRouter;\n\n\n//# sourceURL=webpack://borbot/./src/server/routes/guild.router.ts?")},"./src/server/routes/user.router.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst express_1 = __webpack_require__(/*! express */ "express");\nconst user_controller_1 = __importDefault(__webpack_require__(/*! ../controllers/user.controller */ "./src/server/controllers/user.controller.ts"));\nconst authenticateUser_middleware_1 = __importDefault(__webpack_require__(/*! ../middlewares/authenticateUser.middleware */ "./src/server/middlewares/authenticateUser.middleware.ts"));\nconst UserRouter = (0, express_1.Router)();\nUserRouter.get(\'/\', authenticateUser_middleware_1.default, user_controller_1.default.user_get);\nUserRouter.get(\'/guilds\', authenticateUser_middleware_1.default, user_controller_1.default.user_guilds_get);\nexports["default"] = UserRouter;\n\n\n//# sourceURL=webpack://borbot/./src/server/routes/user.router.ts?')},"./src/server/server.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst express_1 = __importDefault(__webpack_require__(/*! express */ "express"));\nconst cors_1 = __importDefault(__webpack_require__(/*! cors */ "cors"));\nconst body_parser_1 = __importDefault(__webpack_require__(/*! body-parser */ "body-parser"));\nconst cookie_parser_1 = __importDefault(__webpack_require__(/*! cookie-parser */ "cookie-parser"));\nconst auth_router_1 = __importDefault(__webpack_require__(/*! ./routes/auth.router */ "./src/server/routes/auth.router.ts"));\nconst user_router_1 = __importDefault(__webpack_require__(/*! ./routes/user.router */ "./src/server/routes/user.router.ts"));\nconst guild_router_1 = __importDefault(__webpack_require__(/*! ./routes/guild.router */ "./src/server/routes/guild.router.ts"));\nconst error_handler_1 = __importDefault(__webpack_require__(/*! ./handlers/error.handler */ "./src/server/handlers/error.handler.ts"));\nfunction server(client) {\n    const server = (0, express_1.default)();\n    server.set(\'bot\', client);\n    server.use((0, cors_1.default)({\n        origin: process.env.FRONTEND_ADDRESS,\n        credentials: true\n    }));\n    server.use(body_parser_1.default.json());\n    server.use((0, cookie_parser_1.default)());\n    server.use(\'/api/auth\', auth_router_1.default);\n    server.use(\'/api/user\', user_router_1.default);\n    server.use(\'/api/guilds\', guild_router_1.default);\n    server.use(error_handler_1.default);\n    return server;\n}\nexports["default"] = server;\n\n\n//# sourceURL=webpack://borbot/./src/server/server.ts?')},"./src/services/clanService.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ClanClass = void 0;\nconst clickerheroes_1 = __importDefault(__webpack_require__(/*! ../api/clickerheroes */ "./src/api/clickerheroes.ts"));\nconst code_1 = __importDefault(__webpack_require__(/*! ../shared/code */ "./src/shared/code.ts"));\nvar ClanClass;\n(function (ClanClass) {\n    ClanClass[ClanClass["Rogue"] = 1] = "Rogue";\n    ClanClass[ClanClass["Mage"] = 2] = "Mage";\n    ClanClass[ClanClass["Priest"] = 3] = "Priest";\n    ClanClass[ClanClass["Undefined"] = -1] = "Undefined";\n})(ClanClass = exports.ClanClass || (exports.ClanClass = {}));\nvar ClanService;\n(function (ClanService) {\n    async function getClanInformation(uid, pwd) {\n        try {\n            const data = await clickerheroes_1.default.getGuildInfo(uid, pwd);\n            const members = Object.values(data.guildMembers).map(member => ({\n                uid: member.uid,\n                highestZone: parseInt(member.highestZone),\n                nickname: member.nickname,\n                class: parseInt(member.chosenClass),\n                level: parseInt(member.classLevel),\n                lastRewardTimestamp: member.lastRewardTimestamp,\n                lastBonusRewardTimestamp: member.lastBonusRewardTimestamp\n            }));\n            return {\n                name: data.guild.name,\n                masterUid: data.guild.guildMasterUid,\n                members: members,\n                currentRaidLevel: parseInt(data.guild.currentRaidLevel),\n                currentNewRaidLevel: data.guild.currentNewRaidLevel,\n                newRaidLocked: data.guild.newRaidLocked === \'true\',\n                autoJoin: data.guild.autoJoin\n            };\n        }\n        catch (error) {\n            if (error.code === code_1.default.CLICKERHEROES_API_FAILED) {\n                return null;\n            }\n            throw error;\n        }\n    }\n    ClanService.getClanInformation = getClanInformation;\n    async function getClanNewRaid(uid, pwd, clanName) {\n        try {\n            const data = await clickerheroes_1.default.getNewRaid(uid, pwd, clanName);\n            const raid = {\n                level: parseInt(data.raid.level),\n                date: data.raid.date,\n                scores: [],\n                bonusScores: [],\n                weakness: data.raid.weakness,\n                isSuccessful: data.raid.isSuccessful,\n                isBonusAvailable: data.raid.isBonusAvailable,\n                isBonusSuccessful: data.raid.isBonusSuccessful\n            };\n            for (const pair of Object.entries(data.raid.scores)) {\n                raid.scores.push({ uid: pair[0], score: pair[1] });\n            }\n            for (const pair of Object.entries(data.raid.bonusScores)) {\n                raid.bonusScores.push({ uid: pair[0], score: pair[1] });\n            }\n            return raid;\n        }\n        catch (error) {\n            if (error.code === code_1.default.CLICKERHEROES_API_FAILED) {\n                return null;\n            }\n            throw error;\n        }\n    }\n    ClanService.getClanNewRaid = getClanNewRaid;\n    async function getClanMessages(uid, pwd, guildName) {\n        try {\n            const data = await clickerheroes_1.default.getGuildMessages(uid, pwd, guildName);\n            const messages = [];\n            for (const key in data.messages) {\n                const split = data.messages[key].split(\';\', 2);\n                messages.push({ timestamp: parseFloat(key), uid: split[0], content: split[1] });\n            }\n            return messages;\n        }\n        catch (error) {\n            if (error.code === code_1.default.CLICKERHEROES_API_FAILED) {\n                return null;\n            }\n            throw error;\n        }\n    }\n    ClanService.getClanMessages = getClanMessages;\n})(ClanService || (ClanService = {}));\nexports["default"] = ClanService;\n\n\n//# sourceURL=webpack://borbot/./src/services/clanService.ts?')},"./src/services/guildService.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst guild_1 = __importDefault(__webpack_require__(/*! ../models/guild */ "./src/models/guild.ts"));\nconst member_1 = __importDefault(__webpack_require__(/*! ../models/member */ "./src/models/member.ts"));\nconst schedule_1 = __importDefault(__webpack_require__(/*! ../models/schedule */ "./src/models/schedule.ts"));\nvar GuildService;\n(function (GuildService) {\n    async function addGuild(guild_id, uid, pwd) {\n        const schema = {\n            guild_id: guild_id,\n            user_uid: uid,\n            password_hash: pwd\n        };\n        await guild_1.default.create(schema);\n    }\n    GuildService.addGuild = addGuild;\n    async function getGuild(id) {\n        const guild = await guild_1.default.findOne({ guild_id: id });\n        if (!guild)\n            return null;\n        return guild;\n    }\n    GuildService.getGuild = getGuild;\n    async function updateGuild(id, params) {\n        const guild = await GuildService.getGuild(id);\n        if (!guild)\n            return false;\n        if (params.raid_announcement_channel) {\n            guild.raid_announcement_channel = params.raid_announcement_channel;\n        }\n        if (params.raid_fight_role) {\n            guild.raid_fight_role = params.raid_fight_role;\n        }\n        if (params.raid_claim_role) {\n            guild.raid_claim_role = params.raid_claim_role;\n        }\n        if (params.remind_channel) {\n            guild.remind_channel = params.remind_channel;\n        }\n        if (params.milestone_channel) {\n            guild.milestone_channel = params.milestone_channel;\n        }\n        if (params.chat_channel) {\n            guild.chat_channel = params.chat_channel;\n        }\n        await guild.save();\n        return true;\n    }\n    GuildService.updateGuild = updateGuild;\n    async function removeGuild(id) {\n        const guild = await GuildService.getGuild(id);\n        if (!guild)\n            return false;\n        if (guild.schedule) {\n            await schedule_1.default.deleteOne({ _id: guild.schedule });\n        }\n        await member_1.default.deleteMany({ guild_id: id });\n        await guild.deleteOne();\n        return true;\n    }\n    GuildService.removeGuild = removeGuild;\n    async function isGuildSetup(id) {\n        const guild = await guild_1.default.exists({ guild_id: id });\n        return guild !== null;\n    }\n    GuildService.isGuildSetup = isGuildSetup;\n    async function getGuildConnectedMember(params) {\n        const member = await member_1.default.findOne(params);\n        if (!member)\n            return null;\n        return member;\n    }\n    GuildService.getGuildConnectedMember = getGuildConnectedMember;\n    async function getGuildConnected(id) {\n        const members = await member_1.default.find({ guild_id: id });\n        return members;\n    }\n    GuildService.getGuildConnected = getGuildConnected;\n    async function updateGuildConnected(guild_id, list) {\n        for (const connected of list) {\n            if (connected.guild_uid == \'\') {\n                await GuildService.removeGuildConnectedMember({ clan_uid: connected.clan_uid, guild_id: guild_id });\n            }\n            else {\n                await member_1.default.findOneAndUpdate({ clan_uid: connected.clan_uid, guild_id: guild_id }, { guild_uid: connected.guild_uid }, { upsert: true });\n            }\n        }\n    }\n    GuildService.updateGuildConnected = updateGuildConnected;\n    async function removeGuildConnectedMember(member) {\n        const schedule = await GuildService.getGuildSchedule(member.guild_id);\n        if (!schedule)\n            return false;\n        let scheduleIndex = -1;\n        if (\'_id\' in member) {\n            scheduleIndex = schedule.map.findIndex(o => o.member._id.equals(member._id));\n        }\n        else {\n            scheduleIndex = schedule.map.findIndex(o => o.member.guild_id === member.guild_id && o.member.clan_uid === member.clan_uid);\n        }\n        if (scheduleIndex !== -1) {\n            schedule.map.splice(scheduleIndex, 1);\n            await schedule.updateOne({ map: schedule.map });\n        }\n        await member_1.default.findOneAndRemove(member);\n        return true;\n    }\n    GuildService.removeGuildConnectedMember = removeGuildConnectedMember;\n    async function getGuildSchedule(guild_id) {\n        const guild = await GuildService.getGuild(guild_id);\n        if (!guild)\n            return null;\n        let dbSchedule = await schedule_1.default.findOne({ _id: guild.schedule });\n        if (!dbSchedule) {\n            const today = new Date();\n            today.setUTCHours(0, 0, 0, 0);\n            dbSchedule = await schedule_1.default.create({ cycle_start: today, length: 10 });\n            guild.schedule = dbSchedule._id;\n            await guild.save();\n        }\n        const populated = await dbSchedule.populate("map.member");\n        return populated;\n    }\n    GuildService.getGuildSchedule = getGuildSchedule;\n    async function updateGuildSchedule(id, data) {\n        const schedule = await GuildService.getGuildSchedule(id);\n        if (!schedule)\n            return false;\n        for (let i = 0; i < 10; ++i) {\n            const entry = data.entries.find(o => o.index == i + 1);\n            if (!entry)\n                continue;\n            const index = schedule.map.findIndex(o => o.index === i + 1);\n            if (index === -1) {\n                if (entry.member)\n                    schedule.map.push({ member: entry.member, index: i + 1 });\n                continue;\n            }\n            else if (entry.member) {\n                schedule.map[index].member = entry.member;\n            }\n            else {\n                schedule.map.splice(index, 1);\n            }\n        }\n        if (data.channel) {\n            schedule.schedule_channel = data.channel;\n        }\n        if (data.cycle_start) {\n            data.cycle_start.setUTCHours(0, 0, 0, 0);\n            schedule.cycle_start = data.cycle_start;\n        }\n        await schedule.save();\n        return true;\n    }\n    GuildService.updateGuildSchedule = updateGuildSchedule;\n})(GuildService || (GuildService = {}));\nexports["default"] = GuildService;\n\n\n//# sourceURL=webpack://borbot/./src/services/guildService.ts?')},"./src/services/userService.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst discord_1 = __importDefault(__webpack_require__(/*! ../api/discord */ "./src/api/discord.ts"));\nconst user_1 = __importDefault(__webpack_require__(/*! ../models/user */ "./src/models/user.ts"));\nconst code_1 = __importDefault(__webpack_require__(/*! ../shared/code */ "./src/shared/code.ts"));\nconst logger_1 = __importDefault(__webpack_require__(/*! ../shared/logger */ "./src/shared/logger.ts"));\nconst utils_1 = __webpack_require__(/*! ../shared/utils */ "./src/shared/utils.ts");\nvar UserService;\n(function (UserService) {\n    async function createOrUpdateUser(data) {\n        const existing = await user_1.default.findOne({ id: data.id });\n        if (existing) {\n            existing.token = data.token;\n            await existing.save();\n        }\n        else {\n            await user_1.default.create({ id: data.id, token: data.token, guilds: [] });\n        }\n    }\n    UserService.createOrUpdateUser = createOrUpdateUser;\n    async function removeUser(id) {\n        await user_1.default.deleteOne({ id: id });\n    }\n    UserService.removeUser = removeUser;\n    async function getUser(id) {\n        const user = await user_1.default.findOne({ id: id });\n        if (!user)\n            return null;\n        return user;\n    }\n    UserService.getUser = getUser;\n    async function getUserUpdatedGuilds(user) {\n        const isLastUpdated = user.last_update_guilds && Date.now() - user.last_update_guilds < 60000;\n        if (isLastUpdated) {\n            return user.guilds;\n        }\n        try {\n            const data = await discord_1.default.getUserGuilds(user.token);\n            const list = [];\n            for (const guild of data) {\n                list.push({\n                    name: guild.name,\n                    id: guild.id,\n                    icon: (0, utils_1.getGuildIconURL)(guild),\n                    permissions: guild.permissions,\n                    isAdmin: (0, utils_1.isAdmin)(guild.permissions)\n                });\n            }\n            (0, logger_1.default)(`Fetched guilds for user ${user.id}`);\n            await user.updateOne({ guilds: list, last_update_guilds: Date.now() });\n            return list;\n        }\n        catch (error) {\n            const { code, status } = error;\n            if (code === code_1.default.DISCORD_API_ERROR && status === 429) {\n                return user.guilds;\n            }\n            throw error;\n        }\n    }\n    UserService.getUserUpdatedGuilds = getUserUpdatedGuilds;\n})(UserService || (UserService = {}));\nexports["default"] = UserService;\n\n\n//# sourceURL=webpack://borbot/./src/services/userService.ts?')},"./src/shared/code.ts":(__unused_webpack_module,exports)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.CodeMessage = void 0;\nvar Code;\n(function (Code) {\n    Code[Code["INTERNAL_SERVER_ERROR"] = 0] = "INTERNAL_SERVER_ERROR";\n    Code[Code["NO_RESPONSE"] = 1] = "NO_RESPONSE";\n    Code[Code["DISCORD_API_ERROR"] = 2] = "DISCORD_API_ERROR";\n    Code[Code["DISCORD_INVALID_TOKEN"] = 3] = "DISCORD_INVALID_TOKEN";\n    Code[Code["DISCORD_RATE_LIMIT"] = 4] = "DISCORD_RATE_LIMIT";\n    Code[Code["CLICKERHEROES_API_ERROR"] = 5] = "CLICKERHEROES_API_ERROR";\n    Code[Code["CLICKERHEROES_API_FAILED"] = 6] = "CLICKERHEROES_API_FAILED";\n    Code[Code["TOKEN_ERROR"] = 7] = "TOKEN_ERROR";\n    Code[Code["OK"] = 200] = "OK";\n    Code[Code["BAD_REQUEST"] = 400] = "BAD_REQUEST";\n    Code[Code["USER_NO_TOKEN"] = 1000] = "USER_NO_TOKEN";\n    Code[Code["USER_NOT_REGISTERED"] = 1001] = "USER_NOT_REGISTERED";\n    Code[Code["USER_NOT_IN_GUILD"] = 1002] = "USER_NOT_IN_GUILD";\n    Code[Code["USER_NOT_AN_ADMIN"] = 1003] = "USER_NOT_AN_ADMIN";\n    Code[Code["GUILD_REQUIRES_BOT"] = 2000] = "GUILD_REQUIRES_BOT";\n    Code[Code["GUILD_ALREADY_SETUP"] = 2001] = "GUILD_ALREADY_SETUP";\n    Code[Code["GUILD_NOT_SETUP"] = 2002] = "GUILD_NOT_SETUP";\n    Code[Code["GUILD_NO_SCHEDULE"] = 2003] = "GUILD_NO_SCHEDULE";\n    Code[Code["CLAN_INVALID_CREDENTIALS"] = 3000] = "CLAN_INVALID_CREDENTIALS";\n    Code[Code["MEMBER_NOT_EXIST"] = 4000] = "MEMBER_NOT_EXIST";\n})(Code || (Code = {}));\nexports.CodeMessage = {\n    [Code.USER_NO_TOKEN]: \'Path requires authorization\',\n    [Code.USER_NOT_REGISTERED]: \'User not registered\',\n    [Code.USER_NOT_IN_GUILD]: \'User is not in guild\',\n    [Code.USER_NOT_AN_ADMIN]: \'User is not an admin\',\n    [Code.GUILD_REQUIRES_BOT]: \'Guild required bot\',\n    [Code.GUILD_ALREADY_SETUP]: \'Guild already setup\',\n    [Code.GUILD_NOT_SETUP]: "Guild isn\'t setup",\n    [Code.GUILD_NO_SCHEDULE]: "Guild doesn\'t have schedule",\n    [Code.CLAN_INVALID_CREDENTIALS]: \'Invalid clan credentials\',\n    [Code.MEMBER_NOT_EXIST]: \'Member do not exist\'\n};\nexports["default"] = Code;\n\n\n//# sourceURL=webpack://borbot/./src/shared/code.ts?')},"./src/shared/logger.ts":(__unused_webpack_module,exports,__webpack_require__)=>{eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.LoggerType = void 0;\nconst fs_1 = __webpack_require__(/*! fs */ "fs");\nconst utils_1 = __webpack_require__(/*! ./utils */ "./src/shared/utils.ts");\nlet firstWrite = true;\nconst PATH = "./logs/";\nlet filename = PATH;\nvar LoggerType;\n(function (LoggerType) {\n    LoggerType["NORMAL"] = "NORMAL";\n    LoggerType["WARN"] = "WARN";\n    LoggerType["ERROR"] = "ERROR";\n})(LoggerType = exports.LoggerType || (exports.LoggerType = {}));\nfunction logger(msg, type = LoggerType.NORMAL) {\n    const date = new Date(Date.now());\n    let dateMsg = `${(0, utils_1.dateToString)(date, \'Y-M-D h:m:s\')}`;\n    const finalMsg = `[${dateMsg}${(type != LoggerType.NORMAL ? ` ${type}` : "")}] ${msg}`;\n    switch (type) {\n        case LoggerType.NORMAL:\n            console.log(finalMsg);\n            break;\n        case LoggerType.WARN:\n            console.warn(finalMsg);\n            break;\n        case LoggerType.ERROR:\n            console.error(finalMsg);\n            break;\n        default:\n            break;\n    }\n    if (firstWrite) {\n        filename += `log_${(0, utils_1.dateToString)(date)}.txt`.replaceAll(\' \', \'_\').replaceAll(\'-\', \'_\').replaceAll(\':\', \'_\');\n        firstWrite = false;\n    }\n    if (!(0, fs_1.existsSync)(\'./logs\')) {\n        (0, fs_1.mkdirSync)(\'./logs\');\n    }\n    const file = (0, fs_1.openSync)(filename, \'a+\', 0o666);\n    (0, fs_1.writeFileSync)(file, `${finalMsg}\\n`, \'utf-8\');\n    (0, fs_1.closeSync)(file);\n}\nexports["default"] = logger;\n\n\n//# sourceURL=webpack://borbot/./src/shared/logger.ts?')},"./src/shared/utils.ts":function(__unused_webpack_module,exports,__webpack_require__){eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.dateDifference = exports.dateToString = exports.getDateMidnight = exports.decryptAccessToken = exports.generateAccessToken = exports.addCommas = exports.isAdmin = exports.getUserIconURL = exports.getGuildIconURL = void 0;\nconst jwt = __importStar(__webpack_require__(/*! jsonwebtoken */ "jsonwebtoken"));\nconst code_1 = __importDefault(__webpack_require__(/*! ./code */ "./src/shared/code.ts"));\nconst logger_1 = __importStar(__webpack_require__(/*! ./logger */ "./src/shared/logger.ts"));\nconst CDN_ENDPOINT = \'https://cdn.discordapp.com\';\nconst UI_ENDPOINT = \'https://ui-avatars.com/api\';\nfunction getGuildIconURL(guild, size = 64) {\n    if (guild.icon) {\n        return `${CDN_ENDPOINT}/icons/${guild.id}/${guild.icon}.png?size=${size}`;\n    }\n    else {\n        const params = {\n            name: guild.name,\n            background: "494d54",\n            uppercase: "false",\n            color: "dbdcdd",\n            "font-size": "0.33",\n            size: size.toString()\n        };\n        return `${UI_ENDPOINT}?${new URLSearchParams(params).toString()}`;\n    }\n}\nexports.getGuildIconURL = getGuildIconURL;\nfunction getUserIconURL(user, size = 64) {\n    if (user.avatar) {\n        return `${CDN_ENDPOINT}/avatars/${user.id}/${user.avatar}.png?size=${size}`;\n    }\n    else {\n        const params = {\n            name: user.username,\n            background: "494d54",\n            uppercase: "false",\n            color: "dbdcdd",\n            "font-size": "0.33",\n            size: size.toString()\n        };\n        return `${UI_ENDPOINT}?${new URLSearchParams(params).toString()}`;\n    }\n}\nexports.getUserIconURL = getUserIconURL;\nfunction isAdmin(permissions) {\n    const ADMINISTRATOR_FLAG = (1 << 3);\n    return (parseInt(permissions) & ADMINISTRATOR_FLAG) == ADMINISTRATOR_FLAG;\n}\nexports.isAdmin = isAdmin;\nfunction addCommas(n) {\n    const temp = n.toString();\n    return temp.length < 5 ? temp : temp.replace(/(\\d)(?=(\\d{3})+$)/g, "$1,");\n}\nexports.addCommas = addCommas;\nfunction generateAccessToken(uid) {\n    return jwt.sign({ uid: uid }, process.env.TOKEN_SECRET, { expiresIn: 3600 });\n}\nexports.generateAccessToken = generateAccessToken;\nfunction decryptAccessToken(token) {\n    return new Promise((resolve, reject) => {\n        jwt.verify(token, process.env.TOKEN_SECRET, (err, user) => {\n            if (err) {\n                (0, logger_1.default)(`Decrypt token error: ${err.message}`, logger_1.LoggerType.ERROR);\n                reject({ code: code_1.default.TOKEN_ERROR, message: "Token error" });\n                return;\n            }\n            resolve({ uid: user.uid });\n        });\n    });\n}\nexports.decryptAccessToken = decryptAccessToken;\nfunction getDateMidnight(date = new Date()) {\n    date.setUTCHours(0, 0, 0, 0);\n    return date;\n}\nexports.getDateMidnight = getDateMidnight;\nfunction dateToString(date, format = "Y-M-D") {\n    let output = format.replaceAll(/Y+/g, date.getUTCFullYear().toString())\n        .replaceAll(/M+/g, (date.getUTCMonth() + 1).toString().padStart(2, \'0\'))\n        .replaceAll(/D+/g, date.getUTCDate().toString().padStart(2, \'0\'))\n        .replaceAll(/h+/g, date.getUTCHours().toString().padStart(2, \'0\'))\n        .replaceAll(/m+/g, date.getUTCMinutes().toString().padStart(2, \'0\'))\n        .replaceAll(/s+/g, date.getUTCSeconds().toString().padStart(2, \'0\'));\n    return output;\n}\nexports.dateToString = dateToString;\nfunction dateDifference(self, other) {\n    return (self.getTime() - other.getTime()) / 86400000;\n}\nexports.dateDifference = dateDifference;\n\n\n//# sourceURL=webpack://borbot/./src/shared/utils.ts?')},"@discordjs/builders":e=>{e.exports=require("@discordjs/builders")},axios:e=>{e.exports=require("axios")},"body-parser":e=>{e.exports=require("body-parser")},"cookie-parser":e=>{e.exports=require("cookie-parser")},cors:e=>{e.exports=require("cors")},"discord.js":e=>{e.exports=require("discord.js")},"dotenv/config":e=>{e.exports=require("dotenv/config")},express:e=>{e.exports=require("express")},jsonwebtoken:e=>{e.exports=require("jsonwebtoken")},mongoose:e=>{e.exports=require("mongoose")},"text-table":e=>{e.exports=require("text-table")},fs:e=>{e.exports=require("fs")}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(t.exports,t,t.exports,__webpack_require__),t.exports}var __webpack_exports__=__webpack_require__("./src/index.ts")})();